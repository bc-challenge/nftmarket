pragma solidity ^0.8.0;

import "./OPERC20.sol";
import "./OPERC721.sol";


contract NFTMarket  {
    MyERC20 public paymentToken;

    // NFT上架信息结构体
    struct Listing {
        address seller;         // 卖家地址
        address nftContract;    // NFT合约地址
        uint256 tokenId;        // NFT的tokenId
        uint256 price;          // 价格
        bool isActive;          // 是否处于活跃状态
    }

    //所有上架的NFT，使用listingId作为唯一标识
    mapping (uint256 => Listing) public listings;
    uint256 public nextListingId;
    // NFT上架和购买事件
    event NFTListed(uint256 indexed listingId, address indexed seller, address indexed nftContract, uint256 tokenId, uint256 price);
    event NFTSold(uint256 indexed listingId, address indexed buyer, address indexed seller, address nftContract, uint256 tokenId, uint256 price);
    event NFTListingCancelled(uint256 indexed listingId);

    // 构造函数，设置支付代币地址
    constructor(address _paymentTokenAddress) {
        require(_paymentTokenAddress != address(0), "NFTMarket: payment token address cannot be zero");
        paymentToken = MyERC20(_paymentTokenAddress);
    }

    // 上架NFT
    function list(address _nftContract, uint256 _tokenId, uint256 _price) external returns (uint256 s){
        // 检查价格是否大于0
        require(_price > 0, "NFTMarket: price must be greater than zero");

        // 检查NFT合约地址是否有效
        require(_nftContract != address(0), "NFTMarketL NFT contract address cannot be zero");

        // 检查调用者是否为NFT的所有者或已获得授权  
        MyERC721 nfcContract721 = MyERC721(_nftContract); 

        address owner = nfcContract721.ownerOf(_tokenId);

        require(
            owner == msg.sender ||
            nfcContract721.isApprovedForAll(owner, msg.sender) ||
            nfcContract721.getApproved(_tokenId) == msg.sender,
            "NFTMarket: caller is not owner nor approved"
        );

        // 创建新的上架信息
        uint256 listingId = nextListingId;
        listings[listingId] = Listing({
            seller: owner,
            nftContract: _nftContract,
            tokenId: _tokenId,
            price: _price,
            isActive: true
        });

        nextListingId++;

        emit NFTListed(listingId, owner, _nftContract, _tokenId, _price);

        return listingId;


    }

    // 取消上架
    function cancelListing(uint256 _listingId) external  {
        // 检查上架信息是否存在且处于活跃状态
        Listing storage listing = listings[_listingId];
        require(listing.isActive, "NFTMarket: listing is not active");

        // 检查调用者是否为卖家
        require(listing.seller == msg.sender, "NFTMarket: caller is not the seller");

        // 将上架信息标记为非活跃
        listing.isActive = false;

        // 触发NFT上架取消事件
        emit NFTListingCancelled(_listingId);
    }

    // 普通购买NFT功能
    function buyNFT(uint256 _listingId) external  {
        //检查上架信息是否存在且处于活跃状态
        Listing storage listing = listings[_listingId];
        require(listing.isActive, "NFTMarket: listing is not active");

        // 检查买家是否有足够的代币
        require(paymentToken.balanceOf(msg.sender) >= listing.price, "NFTMarket: insuffcient token balance");
        // // 
        // require(paymentToken.allowance(msg.sender, address(this)) >= listing.price, "Insufficient allowance");

        // 将上架信息标记为非活跃
        listing.isActive = false;
        // 买家需要手动对该合约进行授权 
        
        // 处理代币转账(买家 -> 卖家)
        bool success = paymentToken.transferFrom(msg.sender, listing.seller, listing.price);
        require(success, "NFTMarket: token transfer failed");

        // 处理NFT转移（卖家 -> 买家）
        MyERC721(listing.nftContract).transferFrom(listing.seller, msg.sender, listing.tokenId);

        // 触发NFT售出事件
        emit NFTSold(_listingId, msg.sender, listing.seller, listing.nftContract, listing.tokenId, listing.price);
    }
    
}
//. 0xe6daC9fD9Df9EB44058f6D018591ee4A72C86d7c 买家

// 0x307b72401743E3275D3d77A32764300E0c2A7a33  手机 200000

// 0xC756573128C26B7CF025757320EF2B5C69760c7d Account1 100000 NFT持有者 卖家
// 买家 对 NFTMarket 合约 授信 10000 额度token
// 卖家 对 NFTMarket 合约 进行 NFT 授权 
